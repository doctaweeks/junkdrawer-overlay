diff --git a/ChangeLog.md b/ChangeLog.md
index 2a4de58..4e8ab45 100644
--- a/ChangeLog.md
+++ b/ChangeLog.md
@@ -23,16 +23,6 @@ etc.), but unfortunately the version of GDM that ships in Fedora 22-24 does not
 execute the GDM startup scripts at all.  At the moment, the only workaround for
 those recent Fedora releases is to use LightDM.
 
-4. Fixed a deadlock that occurred when exiting ANSYS HFSS 2014.  This fix was
-an extension of 2.3.3[2], necessitated by the fact that MainWin calls X11
-functions from the destructor of one of its shared libraries, which is executed
-after the VGL faker has shut down.  Because VGL 2.5.x enables the XCB
-interposer by default, we have to ensure that any X11 and XCB functions hand
-off immediately to the underlying libraries after the faker has been shut down,
-because even if an X11 function is not interposed by VGL, some of the XCB
-functions it calls might be.  This issue was also known to affect ANSYS Maxwell
-and may have affected other applications that use MainWin.
-
 
 2.5
 ===
diff --git a/server/faker-x11.cpp b/server/faker-x11.cpp
index 94ebb4a..84caaf6 100644
--- a/server/faker-x11.cpp
+++ b/server/faker-x11.cpp
@@ -38,10 +38,10 @@ extern "C" {
 
 int XCloseDisplay(Display *dpy)
 {
-	// MainWin calls various X11 functions from the destructor of one of its
-	// shared libraries, which is executed after the VGL faker has shut down,
-	// so we cannot access fconfig or vglout or winh without causing deadlocks or
-	// other issues.  At this point, all we can safely do is hand off to libX11.
+	// For reasons unexplained, MainWin apps will sometimes call XCloseDisplay()
+	// after the global instances have been destroyed, so if this has occurred,
+	// we can't access fconfig or vglout or winh without causing deadlocks or
+	// other issues.
 	if(vglfaker::deadYet) return _XCloseDisplay(dpy);
 
 	int retval=0;
@@ -85,7 +85,7 @@ int XCopyArea(Display *dpy, Drawable src, Drawable dst, GC gc, int src_x,
 {
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XCopyArea(dpy, src, dst, gc, src_x, src_y, width, height, dest_x,
 			dest_y);
 
@@ -201,7 +201,7 @@ Window XCreateSimpleWindow(Display *dpy, Window parent, int x, int y,
 	Window win=0;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XCreateSimpleWindow(dpy, parent, x, y, width, height, border_width,
 			border, background);
 
@@ -227,7 +227,7 @@ Window XCreateWindow(Display *dpy, Window parent, int x, int y,
 	Window win=0;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XCreateWindow(dpy, parent, x, y, width, height, border_width,
 			depth, c_class, visual, valuemask, attributes);
 
@@ -268,7 +268,7 @@ int XDestroySubwindows(Display *dpy, Window win)
 	int retval=0;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XDestroySubwindows(dpy, win);
 
 		opentrace(XDestroySubwindows);  prargd(dpy);  prargx(win);  starttrace();
@@ -288,7 +288,7 @@ int XDestroyWindow(Display *dpy, Window win)
 	int retval=0;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XDestroyWindow(dpy, win);
 
 		opentrace(XDestroyWindow);  prargd(dpy);  prargx(win);  starttrace();
@@ -311,7 +311,7 @@ int XFree(void *data)
 	int ret=0;
 	TRY();
 	ret=_XFree(data);
-	if(data && !vglfaker::deadYet) vishash.remove(NULL, (XVisualInfo *)data);
+	if(data && !isDead()) vishash.remove(NULL, (XVisualInfo *)data);
 	CATCH();
 	return ret;
 }
@@ -331,7 +331,7 @@ Status XGetGeometry(Display *dpy, Drawable drawable, Window *root, int *x,
 	unsigned int width=0, height=0;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XGetGeometry(dpy, drawable, root, x, y, width_return,
 			height_return, border_width, depth);
 
@@ -374,7 +374,7 @@ XImage *XGetImage(Display *dpy, Drawable drawable, int x, int y,
 	XImage *xi=NULL;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XGetImage(dpy, drawable, x, y, width, height, plane_mask, format);
 
 		opentrace(XGetImage);  prargd(dpy);  prargx(drawable);  prargi(x);
@@ -402,7 +402,7 @@ char **XListExtensions(Display *dpy, int *next)
 
 	TRY();
 
-	if(vglfaker::deadYet || is3D(dpy) || dpyhash.find(dpy))
+	if(is3D(dpy) || dpyhash.find(dpy))
 		return _XListExtensions(dpy, next);
 
 		opentrace(XListExtensions);  prargd(dpy);  starttrace();
@@ -489,7 +489,7 @@ Bool XQueryExtension(Display *dpy, _Xconst char *name, int *major_opcode,
 {
 	Bool retval=True;
 
-	if(vglfaker::deadYet || is3D(dpy) || dpyhash.find(dpy))
+	if(is3D(dpy) || dpyhash.find(dpy))
 		return _XQueryExtension(dpy, name, major_opcode, first_event, first_error);
 
 		opentrace(XQueryExtension);  prargd(dpy);  prargs(name);  starttrace();
@@ -513,7 +513,7 @@ char *XServerVendor(Display *dpy)
 {
 	TRY();
 
-	if(strlen(fconfig.vendor)>0 && !vglfaker::deadYet && !dpyhash.find(dpy))
+	if(strlen(fconfig.vendor)>0 && !dpyhash.find(dpy))
 		return fconfig.vendor;
 	else return _XServerVendor(dpy);
 
@@ -529,10 +529,6 @@ char *XServerVendor(Display *dpy)
 static void handleEvent(Display *dpy, XEvent *xe)
 {
 	VirtualWin *vw=NULL;
-
-	if(vglfaker::deadYet || dpyhash.find(dpy))
-		return;
-
 	if(xe && xe->type==ConfigureNotify)
 	{
 		if(winhash.find(dpy, xe->xconfigure.window, vw))
@@ -576,7 +572,8 @@ Bool XCheckMaskEvent(Display *dpy, long event_mask, XEvent *xe)
 	Bool retval=0;
 	TRY();
 
-	if((retval=_XCheckMaskEvent(dpy, event_mask, xe))==True)
+	if((retval=_XCheckMaskEvent(dpy, event_mask, xe))==True
+		&& !dpyhash.find(dpy))
 		handleEvent(dpy, xe);
 
 	CATCH();
@@ -589,7 +586,8 @@ Bool XCheckTypedEvent(Display *dpy, int event_type, XEvent *xe)
 	Bool retval=0;
 	TRY();
 
-	if((retval=_XCheckTypedEvent(dpy, event_type, xe))==True)
+	if((retval=_XCheckTypedEvent(dpy, event_type, xe))==True
+		&& !dpyhash.find(dpy))
 		handleEvent(dpy, xe);
 
 	CATCH();
@@ -603,7 +601,8 @@ Bool XCheckTypedWindowEvent(Display *dpy, Window win, int event_type,
 	Bool retval=0;
 	TRY();
 
-	if((retval=_XCheckTypedWindowEvent(dpy, win, event_type, xe))==True)
+	if((retval=_XCheckTypedWindowEvent(dpy, win, event_type, xe))==True
+		&& !dpyhash.find(dpy))
 		handleEvent(dpy, xe);
 
 	CATCH();
@@ -616,7 +615,8 @@ Bool XCheckWindowEvent(Display *dpy, Window win, long event_mask, XEvent *xe)
 	Bool retval=0;
 	TRY();
 
-	if((retval=_XCheckWindowEvent(dpy, win, event_mask, xe))==True)
+	if((retval=_XCheckWindowEvent(dpy, win, event_mask, xe))==True
+		&& !dpyhash.find(dpy))
 		handleEvent(dpy, xe);
 
 	CATCH();
@@ -630,7 +630,7 @@ int XConfigureWindow(Display *dpy, Window win, unsigned int value_mask,
 	int retval=0;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XConfigureWindow(dpy, win, value_mask, values);
 
 		opentrace(XConfigureWindow);  prargd(dpy);  prargx(win);
@@ -657,7 +657,7 @@ int XMaskEvent(Display *dpy, long event_mask, XEvent *xe)
 	TRY();
 
 	retval=_XMaskEvent(dpy, event_mask, xe);
-	handleEvent(dpy, xe);
+	if(!dpyhash.find(dpy)) handleEvent(dpy, xe);
 
 	CATCH();
 	return retval;
@@ -670,7 +670,7 @@ int XMoveResizeWindow(Display *dpy, Window win, int x, int y,
 	int retval=0;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XMoveResizeWindow(dpy, win, x, y, width, height);
 
 		opentrace(XMoveResizeWindow);  prargd(dpy);  prargx(win);  prargi(x);
@@ -693,7 +693,7 @@ int XNextEvent(Display *dpy, XEvent *xe)
 	TRY();
 
 	retval=_XNextEvent(dpy, xe);
-	handleEvent(dpy, xe);
+	if(!dpyhash.find(dpy)) handleEvent(dpy, xe);
 
 	CATCH();
 	return retval;
@@ -706,7 +706,7 @@ int XResizeWindow(Display *dpy, Window win, unsigned int width,
 	int retval=0;
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XResizeWindow(dpy, win, width, height);
 
 		opentrace(XResizeWindow);  prargd(dpy);  prargx(win);  prargi(width);
@@ -729,7 +729,7 @@ int XWindowEvent(Display *dpy, Window win, long event_mask, XEvent *xe)
 	TRY();
 
 	retval=_XWindowEvent(dpy, win, event_mask, xe);
-	handleEvent(dpy, xe);
+	if(!dpyhash.find(dpy)) handleEvent(dpy, xe);
 
 	CATCH();
 	return retval;
diff --git a/server/faker-xcb.cpp b/server/faker-xcb.cpp
index b6cac98..f6f2d23 100644
--- a/server/faker-xcb.cpp
+++ b/server/faker-xcb.cpp
@@ -1,4 +1,4 @@
-/* Copyright (C)2014-2016 D. R. Commander
+/* Copyright (C)2014-2015 D. R. Commander
  *
  * This library is free software and may be redistributed and/or modified under
  * the terms of the wxWindows Library License, Version 3.1 or (at your option)
@@ -40,7 +40,7 @@ const xcb_query_extension_reply_t *
 
 	TRY();
 
-	if(!vglfaker::deadYet && ext && !strcmp(ext->name, "GLX") && fconfig.fakeXCB
+	if(ext && !strcmp(ext->name, "GLX") && fconfig.fakeXCB
 		&& vglfaker::getFakerLevel()==0
 		&& !dpyhash.find(xcbconnhash.getX11Display(conn)))
 	{
@@ -79,11 +79,7 @@ xcb_glx_query_version_cookie_t
 
 	TRY();
 
-	// Note that we have to hand off to the underlying XCB libraries if
-	// vglfaker::deadYet==true, because MainWin calls X11 functions (which in
-	// turn call XCB functions) from one of its shared library destructors,
-	// which is executed after the VGL faker has shut down.
-	if(vglfaker::deadYet || !fconfig.fakeXCB || vglfaker::getFakerLevel()>0
+	if(!fconfig.fakeXCB || vglfaker::getFakerLevel()>0
 		|| dpyhash.find(xcbconnhash.getX11Display(conn)))
 		return _xcb_glx_query_version(conn, major_version, minor_version);
 
@@ -111,7 +107,7 @@ xcb_glx_query_version_reply_t *
 
 	TRY();
 
-	if(vglfaker::deadYet || !fconfig.fakeXCB || vglfaker::getFakerLevel()>0
+	if(!fconfig.fakeXCB || vglfaker::getFakerLevel()>0
 		|| dpyhash.find(xcbconnhash.getX11Display(conn)))
 		return _xcb_glx_query_version_reply(conn, cookie, error);
 
@@ -150,9 +146,7 @@ static void handleXCBEvent(xcb_connection_t *conn, xcb_generic_event_t *e)
 {
 	VirtualWin *vw=NULL;
 
-	if(!e || vglfaker::deadYet || !fconfig.fakeXCB
-		|| vglfaker::getFakerLevel()>0)
-		return;
+	if(!e) return;
 
 	switch(e->response_type & ~0x80)
 	{
@@ -230,7 +224,8 @@ xcb_generic_event_t *xcb_poll_for_event(xcb_connection_t *conn)
 
 	TRY();
 
-	if((e=_xcb_poll_for_event(conn))!=NULL)
+	if((e=_xcb_poll_for_event(conn))!=NULL && fconfig.fakeXCB
+		&& vglfaker::getFakerLevel()==0)
 		handleXCBEvent(conn, e);
 
 	CATCH();
@@ -245,7 +240,8 @@ xcb_generic_event_t *xcb_poll_for_queued_event(xcb_connection_t *conn)
 
 	TRY();
 
-	if((e=_xcb_poll_for_queued_event(conn))!=NULL)
+	if((e=_xcb_poll_for_queued_event(conn))!=NULL && fconfig.fakeXCB
+		&& vglfaker::getFakerLevel()==0)
 		handleXCBEvent(conn, e);
 
 	CATCH();
@@ -260,7 +256,8 @@ xcb_generic_event_t *xcb_wait_for_event(xcb_connection_t *conn)
 
 	TRY();
 
-	if((e=_xcb_wait_for_event(conn))!=NULL)
+	if((e=_xcb_wait_for_event(conn))!=NULL && fconfig.fakeXCB
+		&& vglfaker::getFakerLevel()==0)
 		handleXCBEvent(conn, e);
 
 	CATCH();
@@ -275,7 +272,7 @@ void XSetEventQueueOwner(Display *dpy, enum XEventQueueOwner owner)
 
 	TRY();
 
-	if(vglfaker::deadYet || dpyhash.find(dpy))
+	if(dpyhash.find(dpy))
 		return _XSetEventQueueOwner(dpy, owner);
 
 		opentrace(XSetEventQueueOwner);  prargd(dpy);  prargi(owner);
diff --git a/server/faker.h b/server/faker.h
index 3c8b648..9d6d6f6 100644
--- a/server/faker.h
+++ b/server/faker.h
@@ -1,6 +1,6 @@
 /* Copyright (C)2004 Landmark Graphics Corporation
  * Copyright (C)2005, 2006 Sun Microsystems, Inc.
- * Copyright (C)2009, 2011, 2013-2016 D. R. Commander
+ * Copyright (C)2009, 2011, 2013-2015 D. R. Commander
  *
  * This library is free software and may be redistributed and/or modified under
  * the terms of the wxWindows Library License, Version 3.1 or (at your option)
@@ -70,11 +70,20 @@ static inline int drawingToRight(void)
 }
 
 
+static inline int isDead(void)
+{
+	int retval=0;
+	globalMutex.lock(false);
+	retval=vglfaker::deadYet;
+	globalMutex.unlock(false);
+	return retval;
+}
+
+
 #define DIE(f,m) {  \
-	if(!vglfaker::deadYet)  \
+	if(!isDead())  \
 		vglout.print("[VGL] ERROR: in %s--\n[VGL]    %s\n", f, m);  \
-	vglfaker::safeExit(1);  \
-}
+			vglfaker::safeExit(1);}
 
 
 #define TRY() try {
